# ch2. Number

## JS는 하나의 숫자형만을 가진다

- Inter의 iAPX-432 processor를 위한 IEEE 부동소수점 연산 표준(`IEEE 754`)를 차용
- 숫자형이 여러개가 아닌 것은 누군가는 치명적이라고 말하지만, 확연한 장점이기도 하다 : overflow 발생x 숫자형에 의한 에러 발생x 등

## Number와 IEEE 754

- JS의 `Number` 데이터 타입은 64비트 2진 타입
- 부호 비트(1) + 지수 비트(11) + 유효 숫자(53) ==Encoding==> 64비트 words
- 어이없게도 0과 -0이 둘 다 있지만 JS가 최대한 이를 잘 숨기고 있다

- 숫자 표현의 크기를 고정한 방식으로 인해 가끔 혼란이 생긴다는 단점이 있다. 
  - `Number.MAX_SAFE_VALUE`등과 같이 **안전한** 범위를 벗어나면 일반적인 수학적 연산이 **혼돈에 빠진다** : `Number.MAX_VALUE`의 값은 대부분 허상이다
  - `Number.EPSILON`은 1에 더했을 때 1보다 큰 수를 만들어 낼 수 있는 가장 작은 양수이다. 즉, `Number.EPSILON`보다 작은 수는 1에 더해도 여전히 결과가 1이다. 터무니없다. (애초에 이 상수의 존재가 수학적으로 터무니없다.)

## 숫자 리터럴

> 숫자 리터럴의 정체는 JS 내장 불변 숫자 객체

숫자 리터럴 방식을 사용하여 숫자를 호출하면 -> 리터럴과 가장 잘 맞는 숫자 객체에 대한 참조를 생성한다.

## Bit Operator

> JS 수 -> 32비트 정수형 -> JS 수

안전한 54비트형이 아니라서 상위 22비트는 의도치 않게 버려질 수 있음 -> 위험. JS에서 비트 연산자는 거의 쓰이지 않는다

## JS는 10진 소수 값을 제대로 처리할 수 없다

### IEEE 754의 숨겨진 끔찍한 진실

> 0.1과 0.2를 더했을 때 완전한 0.3을 얻을 수 없다니!

- JS의 숫자를 (편이성을 위해 유효 숫자 대신) 계수로 분리하는 함수를 작성하여 `1`과 `0.1`을 넣어보면
  - 1 -> `1 * 9007199... * (2 ** -53)`
  - 0.1 -> `1 * 7205759... * (2 ** -56)`
-> 그러나 실제 수학적 계산으로는 `1 * 7205759... * (2 ** -56)`은 0.1이 아니다. 이는 정확히는 `0.1000000...5511151231257.....`이다.

- 100/3을 넣으면 `33.333333...6`이라는 그럴듯한 값을 내놓지만 사실은 `33.333333...570180911192....`이다. **즉 JS는 그럴듯한 답조차 이해하지 못한다.**

JS는 10진 소수 값을 처리하는 능력이 엉망이며 최대한 정확히 표현하기 위해 alias(별칭)을 사용하지만 이는 치명적이다.